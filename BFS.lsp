#|
***** bfs.lsp ******************************************************************

General-purpose exhaustive search routine include[d] both breadth-first
search and depth-first search. Uses graph search with OPEN and CLOSED
lists rather than tree search, to avoid cycles. Does not use heuristics
to limit or guide search.

To solve a specific problem, the functions "generate-successors" and
"goal-state" must be defined. "Generate-successors" takes a state as its
argument and returns a list of child states. "Goal-state?" returns T if
its argument is a goal state, NIL otherwise.

In order to retrace a solution path, nodes are stored as (state parent)
pairs, where "state" is the current state and "parent" is the parent
state. Given a goal node, a solution path is generated by simply tracing
backwards through the parent states.

Author: John M. Weiss, Ph.D.
Written Spring 2016 for CSC447/547 AI class.

Modifications:

Modified by: Hannah Aker, Derek Lane, Savoy Schuler

The main function (8puzzle.lsp) calls BFS with the puzzle list as an argument. 
The bfs function then passes the first number (the first node of the list) to 
the search_bfs which produces the most optimal solution, storing the path from 
goal to start in the node struct which stores parent-child relationships. After
returning from bfs_search, bfs will format and print collected statistics on the
number of moves necessary to solve the puzzle and then print each step of the 
solution using the parent-child relation ships stored in the node struct.

The bfs function was based on the example provided by Dr. John Weiss but has 
been modified to include formatting and outputting statistics and a graphical 
represenation of the solution path.

Parameters: 
puzzle - a puzzle state
GOAL

Returns: None
********************************************************************************
|#

(defun bfs (start N)
	(let ((solution))
		;the solution will be the list returned from the dfs function.
		(setf solution (search_bfs start N))	
		
		(format t " BFS graph search~% --------------~% Solution found in ~d moves~% ~d nodes generated (~d distinct nodes), ~d nodes expanded~%~%" 
		(- (length solution) 1) *nodes-generated* *nodes-distinct* *nodes-expanded* )
		(printstates solution N)
	)
)


#|
***** search_bfs.lsp ***********************************************************

General-purpose exhaustive search routine include[d] both breadth-first
search and depth-first search. Uses graph search with OPEN and CLOSED
lists rather than tree search, to avoid cycles. Does not use heuristics
to limit or guide search.

To solve a specific problem, the functions "generate-successors" and
"goal-state" must be defined. "Generate-successors" takes a state as its
argument and returns a list of child states. "Goal-state?" returns T if
its argument is a goal state, NIL otherwise.

In order to retrace a solution path, nodes are stored as (state parent)
pairs, where "state" is the current state and "parent" is the parent
state. Given a goal node, a solution path is generated by simply tracing
backwards through the parent states.

Author: John M. Weiss, Ph.D.
Written Spring 2016 for CSC447/547 AI class.

Modifications:

Modified by: Hannah Aker, Derek Lane, Savoy Schuler

This function contains the BFS search algorithm written by Dr. John Weiss. This 
function was modified to exclude functionality for the DFS search option as
DFS is not a valid search for the 8 Puzzle problem. The justification for this 
decision is that DFS does not return the optimal path. Because DFS does not
prioritize breadth, it would run for an unreasonable amount of time and the
produced solution, if any, would be negligible compared to far more optimal 
solutions paths. Additionally, the *nodes-generated* variable was added and 
incremented after each instance of node generation for the purpose statistic 
tracking and outputing after returning to the bfs function. 

"generate-successors" and "goal-state" functions were defined in utilities.lsp

Line lengths exceeding 80 characters were attempted to be avoided, but doing so
unreasonbly complicated readability of the code. Thus it is noted readability 
was prefered over compressing the length of individual lines. 
********************************************************************************
|#

; Breadth-first-search implements the OPEN list as a QUEUE of (state parent) nodes.
; Given a start state and a search type (BFS or DFS), return a path from the start to the goal.
(defun search_bfs (start N)
	;initialize path variables
	(setf *nodes-distinct* 0)	 
	(setf *nodes-generated* 0)
	(setf *nodes-expanded* 0)
	; note use of sequential DO*
	(do*        
		; initialize local loop vars                                            
		(   
			; current node: (start nil)
			(curNode (make-node :state start :parent nil))  
			
			; OPEN list:    ((start nil))
			(OPEN (list curNode)) 
			
			; CLOSED list:  ( )
			(CLOSED nil)                                    
		)
		
		; termination condition - return solution path when goal is found
		((goal-state? (node-state curNode) N) (build-solution curNode CLOSED))
		
		; loop body
		(when (null OPEN) (return nil))             ; no solution
		
		;increment the number of expanded nodes
		(setf *nodes-expanded* (+ 1 *nodes-expanded*))
		; get current node from OPEN, update OPEN and CLOSED
		(setf curNode (car OPEN))
		
		(setf OPEN (cdr OPEN))
		(setf CLOSED (cons curNode CLOSED))
		
		; add successors of current node to OPEN
		(dolist (child (generate-successors (node-state curNode) N))
			
			; for each child node
			(setf child (make-node :state child :parent (node-state curNode)))
			;increment the number of generated nodes
			(setf *nodes-generated* (+ 1 *nodes-generated*)) 
			
			; if the node is not on OPEN or CLOSED
			(if (and (not (member child OPEN   :test #'equal-states))
			(not (member child CLOSED :test #'equal-states)))
			(progn
				;increment the number of distinct nodes
				(setf *nodes-distinct* (+ 1 *nodes-distinct*)) 
				; add it to the OPEN list
				; BFS - add to end of OPEN list (queue)
				(setf OPEN (append OPEN (list child)))   
			)
			)
		)
	)
)

